#!/usr/bin/env sh

if [ -z "$KEYS_LOCATION" ]; then
	echo "KEYS_LOCATION variable is not set. Please set it to the directory where you want to store the keys."
	exit 1
fi

if ! kubectl cluster-info --request-timeout=3s >/dev/null 2>&1; then
	echo "Kubernetes cluster is not accessible. Please check your connection."
	exit 1
fi

rm .env
echo "# ------------------------------------------------------------------------" >>.env
echo "# DO NOT EDIT THIS FILE MANUALLY." >>.env
echo "# This file is automatically generated by scripts/create-env-file.sh and will be" >>.env
echo "# deleted and recreated from scratch when the script is run. Any manual changes will" >>.env
echo "# be lost." >>.env
echo "# ------------------------------------------------------------------------" >>.env

echo "RELEASE_NAME={{template-agent}}" >>.env

# The services accessed by the service kit sidecar on Docker container doesn't resolve cluster DNS names.
# So we need to use the cluster IPs instead.
IP=$(kubectl get service feature-flags-ld-relay -o jsonpath='{.spec.clusterIP}')
echo "LAUNCHDARKLY_STREAM_URI=http://$IP:8080/relay" >>.env

IP=$(kubectl get svc keys -n qcs-keys -o jsonpath='{.spec.clusterIP}')
echo "KEYS_URI=http://$IP:8080" >>.env

IP=$(kubectl get svc edge-auth -o jsonpath='{.spec.clusterIP}')
echo "EDGE_AUTH_URI=http://$IP:8080" >>.env

IP=$(kubectl get svc encryption -o jsonpath='{.spec.clusterIP}')
echo "ENCRYPTION_URI=http://$IP:8080" >>.env

IP=$(kubectl get svc solace-pubsubplus -o jsonpath='{.spec.clusterIP}')
echo "SOLACE_URI=tcps://$IP:55443" >>.env

echo "LLM_GATEWAY_API_URI=http://ai-platform-api.ai-platform.svc.cluster.local:8080" >>.env
echo "SPACES_URI=http://spaces.default.svc.cluster.local:6080" >>.env

echo "\n#settings" >>.env

echo "AWS_DEFAULT_REGION=us-east-1" >>.env
echo "REGION=us-east-1" >>.env
echo "SIDECAR_DISABLE_AUTH=true" >>.env
echo "SOLACE_SKIP_CERT_VALIDATION=true" >>.env
echo "SOLACE_MESSAGE_VPN=QcsPrimary" >>.env
echo "GRPC_SIDECAR_OVERRIDE=false" >>.env

echo "\n#secrets" >>.env
echo "SECRET_KEY_FILE=$KEYS_LOCATION/service-key.yaml" >>.env
echo "SIDECAR_SHARED_SECRET_LOCATION=$KEYS_LOCATION/sidecarSecret.yaml" >>.env
echo "JWKS_PATH=/var/run/secrets/qlik.com/{{template-agent}}-keys/service-key.yaml" >>.env

# Get the pod name associated with the service
service={{template-agent}}
namespace=analytics-ai
podname=$(kubectl get pods -n $namespace -l app=$service | awk 'NR==2{print $1}')
echo "$podname"

kubectl exec -c $service -n $namespace "$podname" -- sh -c 'echo "LAUNCHDARKLY_SDK_KEY=$LAUNCHDARKLY_SDK_KEY"' >>.env
kubectl exec -c "$service" -n $namespace "$podname" -- sh -c 'cat "$MONGODB_URI_FILE"' | awk '{print "MONGODB_URI=\"" $0 "\"" }' >>.env

echo "Done!"
